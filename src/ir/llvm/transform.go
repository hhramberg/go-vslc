// package llvm provides functions for taking the ir.Node syntax tree generated by the goyacc parser and turning it
// into LLVM framework intermediate representation.

package llvm

import (
	"errors"
	"fmt"
	"strings"
	"sync"
)

import (
	"github.com/llir/llvm/ir"
	"github.com/llir/llvm/ir/constant"
	"github.com/llir/llvm/ir/enum"
	"github.com/llir/llvm/ir/types"
	"github.com/llir/llvm/ir/value"
)

import (
	vir "vslc/src/ir"
	"vslc/src/util"
)

// ----------------------------
// ----- Type definitions -----
// ----------------------------

// funcWrapper wraps a function's LLVM entry and syntax tree root node.
type funcWrapper struct {
	ll   *ir.Func  // The LLVM entry of this function.
	node *vir.Node // The syntax tree node of this function.
}

// symTab wraps a hash table used for accessing variable pointers thread safe.
type symTab struct {
	ht         map[string]interface{} // Hash table holding variable pointers.
	sync.Mutex                        // For synchronising worker threads.
}

// ---------------------
// ----- Constants -----
// ---------------------

// word64 defines machine word size for 32-bit architectures.
//const word64 = 8

// word32 defines machine word size for 32-bit architectures.
//const word32 = 4

// mapSize defines the initial size of local scope symbol tables.
const mapSize = 16

// -------------------
// ----- Globals -----
// -------------------

var i = types.I64   // Defaults to 64-bit integers.
var f = types.Float // Defaults to 64-bit (???) float.

// wordSize defines the machine word size for the current compilation instance.
//var wordSize = word64

// Global symbol table for pointers to value.Values declared in module.
var globals symTab

// ---------------------
// ----- Functions -----
// ---------------------

// GenLLVM generates LLVM intermediate representation of the parse tree provided by goyacc.
// VSL is single module, because it has no concept of modules in the first place.
func GenLLVM(opt util.Options, root *vir.Node) error {
	if opt.Target == util.Riscv32 {
		i = types.I32
	}

	globals = symTab{
		ht: make(map[string]interface{}, mapSize), // Assume no more than 16 global definitions.
	}

	m := ir.NewModule()

	if opt.Threads > 1 {
		// Parallel.
		funcs := make([]funcWrapper, 0, len(root.Children[0].Children)) // Allocate sufficient space.

		mx := sync.Mutex{}     // For synchronising access to module m.
		wg := sync.WaitGroup{} // For synchronising main thread with worker threads.

		t := opt.Threads
		l := cap(funcs)
		if t > l {
			// Can't spawn more threads than jobs.
			t = l
		}
		n := l / t   // Number of jobs per thread.
		res := l % t // Number of threads that have to do extra work.

		// Listen for errors.
		cerr := make(chan error, l)

		// Spawn worker t worker threads.
		for i1 := 0; i1 < t; i1++ {
			wg.Add(1)
			go func(i1 int, wg *sync.WaitGroup, mx *sync.Mutex, cerr chan error) {
				// Make sure to tell main thread that worker thread terminates when job is done.
				defer wg.Done()

				// Spawn n jobs plus residual jobs if applicable.
				for i2 := 0; (i1 < res && i2 < n+1) || i2 < n; i2++ {
					e := root.Children[0].Children[i1+i2]
					switch e.Typ {
					case vir.DECLARATION:
						var typ types.Type
						switch e.Data.(string) {
						case "int":
							typ = i
						case "float":
							typ = f
						default:
							cerr <- fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
								e.Line, e.Pos, "int", "float", e.Data.(string))
							return
						}
						for _, e2 := range e.Children[0].Children {
							// Add all global declarations of this variable list.
							mx.Lock()
							glob := m.NewGlobal(e2.Data.(string), typ)
							mx.Unlock()
							globals.Lock()
							globals.ht[e2.Data.(string)] = glob
							globals.Unlock()
						}
					case vir.FUNCTION:
						name := e.Children[0].Data.(string)

						// Return type.
						var typ types.Type
						switch e.Children[1].Data.(string) {
						case "int":
							typ = i
						case "float":
							typ = f
						default:
							cerr <- fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
								e.Line, e.Pos, "int", "float", e.Data.(string))
							return
						}

						// Parameters.
						params := make([]*ir.Param, 0, 8) // Pre-allocate 8 parameters.
						for _, e2 := range e.Children[2].Children {
							var typ types.Type
							switch e.Children[1].Data.(string) {
							case "int":
								typ = i
							case "float":
								typ = f
							default:
								cerr <- fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
									e.Line, e.Pos, "int", "float", e.Data.(string))
								return
							}
							for _, e3 := range e2.Children {
								params = append(params, ir.NewParam(e3.Data.(string), typ))
							}
						}

						// Append function.
						mx.Lock()
						wrapper := funcWrapper{
							ll:   m.NewFunc(name, typ, params...),
							node: e,
						}
						mx.Unlock()
						funcs = append(funcs, wrapper)
					}
				}
			}(i1, &wg, &mx, cerr)
		}

		// Wait for worker threads to finish.
		wg.Wait()

		if len(cerr) > 0 {
			for e1 := range cerr {
				fmt.Println(e1)
			}
			return fmt.Errorf("%d erors when creating LLVM intermediate representation", len(cerr))
		}
		return nil
	} else {
		// Sequential.
		funcs := make([]funcWrapper, 0, len(root.Children[0].Children)) // Allocate sufficient space.

		for _, e1 := range root.Children[0].Children {
			// For every member of GLOBAL_LIST.
			switch e1.Typ {
			case vir.DECLARATION:
				var typ types.Type
				switch e1.Data.(string) {
				case "int":
					typ = i
				case "float":
					typ = f
				default:
					return fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
						e1.Line, e1.Pos, "int", "float", e1.Data.(string))
				}
				for _, e2 := range e1.Children[0].Children {
					// Add all global declarations of this variable list.
					m.NewGlobal(e2.Data.(string), typ)
					//globals.put(e2.Data.(string), r)
				}
			case vir.FUNCTION:
				name := e1.Children[0].Data.(string)

				// Return type.
				var typ types.Type
				switch e1.Children[1].Data.(string) {
				case "int":
					typ = i
				case "float":
					typ = f
				default:
					return fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
						e1.Line, e1.Pos, "int", "float", e1.Data.(string))
				}

				// Parameters.
				params := make([]*ir.Param, 0, 8) // Pre-allocate 8 parameters.
				for _, e2 := range e1.Children[2].Children {
					var typ types.Type
					switch e1.Children[1].Data.(string) {
					case "int":
						typ = i
					case "float":
						typ = f
					default:
						return fmt.Errorf("line %d:%d: expected data type %q or %q, got %q",
							e1.Line, e1.Pos, "int", "float", e1.Data.(string))
					}
					for _, e3 := range e2.Children {
						params = append(params, ir.NewParam(e3.Data.(string), typ))
					}
				}

				// Append function.
				wrapper := funcWrapper{
					ll:   m.NewFunc(name, typ, params...),
					node: e1,
				}
				funcs = append(funcs, wrapper)
			}
		}
		for _, e1 := range funcs {
			b := e1.ll.NewBlock("")
			st := util.Stack{}                             // Scope stack. For retrieving correct variable.
			ls := util.Stack{}                             // Loop stack. For continuing correct loop.
			st.Push(make(map[string]interface{}, mapSize)) // Put map directly onto stack. It's used by single worker thread.
			if _, err := gen(m, e1.ll, b, e1.node.Children[3], &st, &ls); err != nil {
				return err
			}
			st.Pop()
		}
	}

	fmt.Println(m.String()) // TODO: delete.
	return nil
}

// gen generates LLVM IR recursively from the syntax tree node n. The input node n MUST be child of a function node,
// and MUST NOT be on the same depth or above a function node.
func gen(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st, ls *util.Stack) (*ir.Block, error) {
	switch n.Typ {
	case vir.BLOCK:
		st.Push(make(map[string]interface{}, mapSize))
		for _, e1 := range n.Children {
			if block, err := gen(m, fun, b, e1, st, ls); err != nil {
				return nil, err
			} else {
				b = block
			}
		}
		st.Pop()
		return b, nil
	case vir.EXPRESSION:
		if _, err := genExpression(m, fun, b, n, st); err != nil {
			return nil, err
		}
	case vir.DECLARATION:
		if err := genDeclaration(b, n, st); err != nil {
			return nil, err
		}
	case vir.ASSIGNMENT_STATEMENT:
		if err := genAssign(m, fun, b, n, st); err != nil {
			return nil, err
		}
	case vir.IF_STATEMENT:
		if conv, err := genIf(m, fun, b, n, st, ls); err != nil {
			return nil, err
		} else {
			// Set basic block to populate equal the new basic block returned from
			// IF-THEN-ELSE convergence.
			return conv, nil
		}
	case vir.WHILE_STATEMENT:
		if conv, err := genWhile(m, fun, b, n, st, ls); err != nil {
			return nil, err
		} else {
			// Set basic block to populate equal the new basic block returned from
			// IF-THEN-ELSE convergence.
			return conv, nil
		}
	case vir.RETURN_STATEMENT:
		// Return terminates the block and function.
		return nil, genReturn(m, fun, b, n, st)
	case vir.PRINT_STATEMENT:
		if err := genPrint(m, fun, b, n, st); err != nil {
			return nil, err
		}
	case vir.NULL_STATEMENT:
		// Continue statement.
		if block, err := genContinue(b, ls); err != nil {
			return nil, err
		} else {
			return block, nil
		}
	default:
		for _, e1 := range n.Children {
			if block, err := gen(m, fun, b, e1, st, ls); err != nil {
				return nil, err
			} else {
				b = block
			}
		}
	}
	return b, nil
}

// genExpression generates an expression recursively to the current LLVM basic block b.
func genExpression(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st *util.Stack) (value.Value, error) {
	if n.Data == nil {
		// Function call.
		name := n.Children[0].Data.(string)
		args := make([]value.Value, 0, 8) // Assume no more than 8 arguments.

		for _, e1 := range n.Children[1].Children[0].Children {
			switch e1.Typ {
			case vir.INTEGER_DATA:
				args = append(args, constant.NewInt(i, int64(e1.Data.(int))))
			case vir.FLOAT_DATA:
				args = append(args, constant.NewFloat(f, float64(e1.Data.(float32))))
			case vir.EXPRESSION:
				if r, err := genExpression(m, fun, b, e1, st); err != nil {
					return nil, err
				} else {
					args = append(args, r)
				}
			case vir.IDENTIFIER_DATA:
				if r, err := genLoad(e1.Data.(string), m, fun, b, st); err != nil {
					return nil, err
				} else {
					args = append(args, r)
				}
			}
		}

		var fun *ir.Func

		// Find function in module. VSL doesn't support local functions.
		for _, e1 := range m.Funcs {
			if e1.Name() == name {
				fun = e1
			}
		}

		if fun == nil {
			return nil, fmt.Errorf("undefined function %q", name)
		}
		return b.NewCall(fun, args...), nil
	}
	var op1, op2, res value.Value // Operands.

	if len(n.Children) == 2 {
		// Binary expression.
		c1 := n.Children[0]
		c2 := n.Children[1]

		fmt.Printf("generating EXPRESSION\n%s %s %s\n", c1.String(), n.Data.(string), c2.String()) // TODO: Delete.
		// Operand 1.
		switch c1.Typ {
		case vir.INTEGER_DATA:
			op1 = constant.NewInt(i, int64(c1.Data.(int)))
		case vir.FLOAT_DATA:
			op1 = constant.NewFloat(f, float64(c1.Data.(float32)))
		case vir.EXPRESSION:
			if r, err := genExpression(m, fun, b, c1, st); err != nil {
				return nil, err
			} else {
				op1 = r
			}
		case vir.IDENTIFIER_DATA:
			if r, err := genLoad(c1.Data.(string), m, fun, b, st); err != nil {
				return nil, err
			} else {
				op1 = r
			}
		}

		// Operand 2.
		switch c2.Typ {
		case vir.INTEGER_DATA:
			op2 = constant.NewInt(i, int64(c2.Data.(int)))
		case vir.FLOAT_DATA:
			op2 = constant.NewFloat(f, float64(c2.Data.(float32)))
		case vir.EXPRESSION:
			if r, err := genExpression(m, fun, b, c2, st); err != nil {
				return nil, err
			} else {
				op2 = r
			}
		case vir.IDENTIFIER_DATA:
			if r, err := genLoad(c2.Data.(string), m, fun, b, st); err != nil {
				return nil, err
			} else {
				op2 = r
			}
		}

		// Operator.
		switch n.Data.(string) {
		case "+":
			res = b.NewAdd(op1, op2)
		case "-":
			res = b.NewSub(op1, op2)
		case "*":
			res = b.NewMul(op1, op2)
		case "/":
			res = b.NewSDiv(op1, op2)
		case "%":
			res = b.NewSRem(op1, op2)
		case "<<":
			res = b.NewShl(op1, op2)
		case ">>":
			res = b.NewLShr(op1, op2)
		case "|":
			res = b.NewOr(op1, op2)
		case "&":
			res = b.NewAnd(op1, op2)
		case "^":
			res = b.NewXor(op1, op2)
		default:
			return nil, fmt.Errorf("operator %q not defined for VSL", n.Data.(string))
		}
	} else {
		// Unary expression.
		c1 := n.Children[0]

		// Operand 1.
		switch c1.Typ {
		case vir.INTEGER_DATA:
			op1 = constant.NewInt(i, int64(c1.Data.(int)))
		case vir.FLOAT_DATA:
			op1 = constant.NewFloat(f, float64(c1.Data.(float32)))
		case vir.EXPRESSION:
			if r, err := genExpression(m, fun, b, c1, st); err != nil {
				return nil, err
			} else {
				op1 = r
			}
		case vir.IDENTIFIER_DATA:
			if r, err := genLoad(c1.Data.(string), m, fun, b, st); err != nil {
				return nil, err
			} else {
				op1 = r
			}
		}

		// Operator.
		switch n.Data.(string) {
		case "~":
			res = b.NewXor(op1, constant.NewInt(i, ^int64(0))) // XOR with all bits set high.
		case "-":
			res = b.NewMul(op1, constant.NewInt(i, -1))
		default:
			return nil, fmt.Errorf("operator %q not defined for VSL", n.Data.(string))
		}
	}
	fmt.Printf("returning expression result: %s\n", res.String())
	return res, nil
}

// genDeclaration generates a declaration to the current LLVM basic block b.
func genDeclaration(b *ir.Block, n *vir.Node, st *util.Stack) error {
	var typ types.Type
	switch n.Data.(string) {
	case "int":
		typ = i
	case "float":
		typ = f
	default:
		return fmt.Errorf("data type %q not defined", n.Data.(string))
	}
	scope := st.Peek().(map[string]interface{})
	for _, e1 := range n.Children[0].Children {
		decl := b.NewAlloca(typ)
		fmt.Printf("new declaration for %q: allocating on stack as %s\n", e1.Data.(string), decl) // TODO: delete.
		scope[e1.Data.(string)] = decl
	}
	return nil
}

// genAssign generates an assignment recursively and appends the LLVM assignment to the current basic block b.
func genAssign(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st *util.Stack) error {
	name := n.Children[0].Data.(string)
	c1 := n.Children[1]

	switch c1.Typ {
	case vir.INTEGER_DATA:
		fmt.Printf("assigning %s to variable %q\n", c1.String(), name)
		tmp1 := constant.NewInt(i, int64(c1.Data.(int)))
		if err := genStore(tmp1, name, m, fun, b, st); err != nil {
			return err
		}
	case vir.FLOAT_DATA:
		fmt.Printf("assigning %s to variable %q\n", c1.String(), name)
		tmp1 := constant.NewFloat(f, float64(c1.Data.(float32)))
		if err := genStore(tmp1, name, m, fun, b, st); err != nil {
			return err
		}
	case vir.EXPRESSION:
		fmt.Printf("assigning %s to variable %q\n", c1.String(), name)
		if tmp1, err := genExpression(m, fun, b, c1, st); err != nil {
			return err
		} else {
			if err = genStore(tmp1, name, m, fun, b, st); err != nil {
				return err
			}
		}
	case vir.IDENTIFIER_DATA:
		fmt.Printf("assigning %s to variable %q\n", c1.String(), name)
		if src, err := genLoad(c1.Data.(string), m, fun, b, st); err != nil {
			return err
		} else {
			if err = genStore(src, name, m, fun, b, st); err != nil {
				return err
			}
		}
	}
	return nil
}

// genReturn generates a function return statement.
func genReturn(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st *util.Stack) error {
	c1 := n.Children[0]
	switch c1.Typ {
	case vir.INTEGER_DATA:
		b.NewRet(constant.NewInt(i, int64(c1.Data.(int))))
	case vir.FLOAT_DATA:
		b.NewRet(constant.NewFloat(f, float64(c1.Data.(float32))))
	case vir.IDENTIFIER_DATA:
		if r, err := genLoad(c1.Data.(string), m, fun, b, st); err != nil {
			return err
		} else {
			b.NewRet(r)
		}
	case vir.EXPRESSION:
		if r, err := genExpression(m, fun, b, c1, st); err != nil {
			return err
		} else {
			b.NewRet(r)
		}
	}
	return nil
}

// genPrint generates print statement IR.
func genPrint(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st *util.Stack) error {
	var pf *ir.Func
	globals.Lock()
	for _, e1 := range m.Funcs {
		if e1.Name() == "printf" {
			pf = e1
			break
		}
	}

	if pf == nil {
		// Define printf.
		format := ir.NewParam("format", types.I8Ptr)
		vargs := ir.NewParam("args", types.Metadata) // TODO: fix.
		pf = m.NewFunc("printf", types.I32, format, vargs)
	}
	globals.Unlock()

	// Iterate over print list.
	args := make([]value.Value, len(n.Children[0].Children)+1)
	wb := strings.Builder{}
	for i1, e1 := range n.Children[0].Children {
		switch e1.Typ {
		case vir.STRING_DATA:
			wb.WriteString("%s")
			args[i1+1] = constant.NewCharArrayFromString(e1.Data.(string))
		case vir.INTEGER_DATA:
			wb.WriteString("%d")
			args[i1+1] = constant.NewInt(i, int64(e1.Data.(int)))
		case vir.FLOAT_DATA:
			wb.WriteString("%f")
			args[i1+1] = constant.NewFloat(f, float64(e1.Data.(float32)))
		case vir.EXPRESSION:
			if r, err := genExpression(m, fun, b, e1, st); err != nil {
				return err
			} else {
				if r.Type() == i {
					wb.WriteString("%d")
				} else {
					wb.WriteString("%f")
				}
				args[i1+1] = r
			}
		case vir.IDENTIFIER_DATA:
			if r, err := genLoad(e1.Data.(string), m, fun, b, st); err != nil {
				return err
			} else {
				if r.Type() == i {
					wb.WriteString("%d")
				} else {
					wb.WriteString("%f")
				}
				args[i1+1] = r
			}
		default:
			return fmt.Errorf("print statement expected node of type STRING, INTEGER, FLOAT, EXPRESSION or "+
				"IDENTIFIER, got %s", e1.Type())
		}
		if i1 < len(n.Children[0].Children)-1 {
			wb.WriteRune(' ')
		}
	}
	args[0] = constant.NewCharArrayFromString(wb.String())

	// Call printf.
	b.NewCall(pf, args...)
	return nil
}

// genRelation generates a relation and returns the boolean value of the relation.
func genRelation(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st *util.Stack) (value.Value, error) {
	c1 := n.Children[0]
	c2 := n.Children[1]

	var op1, op2, ret value.Value

	// Operand 1.
	switch c1.Typ {
	case vir.INTEGER_DATA:
		op1 = constant.NewInt(i, int64(c1.Data.(int)))
	case vir.FLOAT_DATA:
		op1 = constant.NewFloat(f, float64(c1.Data.(float32)))
	case vir.IDENTIFIER_DATA:
		if val, err := genLoad(c1.Data.(string), m, fun, b, st); err != nil {
			return nil, err
		} else {
			op1 = val
		}
	case vir.EXPRESSION:
		if val, err := genExpression(m, fun, b, c1, st); err != nil {
			return nil, err
		} else {
			op1 = val
		}
	}

	// Operand 2.
	switch c2.Typ {
	case vir.INTEGER_DATA:
		op2 = constant.NewInt(i, int64(c2.Data.(int)))
	case vir.FLOAT_DATA:
		op2 = constant.NewFloat(f, float64(c2.Data.(float32)))
	case vir.IDENTIFIER_DATA:
		if val, err := genLoad(c2.Data.(string), m, fun, b, st); err != nil {
			return nil, err
		} else {
			op2 = val
		}
	case vir.EXPRESSION:
		if val, err := genExpression(m, fun, b, c2, st); err != nil {
			return nil, err
		} else {
			op2 = val
		}
	}

	// Convert types if necessary.
	if op1.Type() != op2.Type() {
		// Must convert one of the types.
		if op1.Type() == f {
			op2 = b.NewBitCast(op2, f)
		} else {
			op1 = b.NewBitCast(op1, f)
		}
	}

	// Operator.
	switch n.Data.(string) {
	case "=":
		if op1.Type() == i {
			ret = b.NewICmp(enum.IPredEQ, op1, op2)
		} else {
			ret = b.NewFCmp(enum.FPredOEQ, op1, op2)
		}
	case "<":
		if op1.Type() == i {
			ret = b.NewICmp(enum.IPredSLT, op1, op2)
		} else {
			ret = b.NewFCmp(enum.FPredOLT, op1, op2)
		}
	case ">":
		if op1.Type() == i {
			ret = b.NewICmp(enum.IPredSGT, op1, op2)
		} else {
			ret = b.NewFCmp(enum.FPredOGT, op1, op2)
		}
	default:
		return nil, fmt.Errorf("undefined relation operator %q", n.Children[0].Data.(string))
	}
	return ret, nil
}

// genIf generates an IF-statement, and recursively generates the THEN and ELSE parts in their respective basic blocks.
func genIf(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st, ls *util.Stack) (*ir.Block, error) {
	rel := n.Children[0]
	c1 := n.Children[1]
	var val value.Value

	// Generate relation for branch.
	if v, err := genRelation(m, fun, b, rel, st); err != nil {
		return nil, err
	} else {
		val = v
	}

	thn := fun.NewBlock("")

	if len(n.Children) == 2 {
		// IF-THEN
		conv := fun.NewBlock("")
		b.NewCondBr(val, thn, conv)

		// Generate THEN body.
		block, err := gen(m, fun, thn, c1, st, ls)
		if err != nil {
			return nil, err
		}

		if block != nil {
			// Body does not contain return statement. Jump to converging basic block.
			thn.NewBr(conv)
			b = conv
		}
	} else {
		// IF-THEN-ELSE
		c2 := n.Children[2]
		els := fun.NewBlock("")
		b.NewCondBr(val, thn, els)
		var conv *ir.Block

		// Generate THEN body.
		block, err := gen(m, fun, thn, c1, st, ls)
		if err != nil {
			return nil, err
		}

		if block != nil {
			// Body does not contain return statement.
			// Jump from THEN to converging basic block.
			conv = fun.NewBlock("")
			thn.NewBr(conv)
			b = conv
		}

		// Generate ELSE body.
		block, err = gen(m, fun, els, c2, st, ls)
		if err != nil {
			return nil, err
		}

		if block != nil {
			// Body does not contain return statement.
			// Jump from ELSE to converging basic block.
			if conv == nil {
				conv = fun.NewBlock("converge")
			}
			els.NewBr(conv)
			b = conv
		}
	}
	return b, nil
}

// genWhile generates a WHILE-statement, and recursively generates the LOOP BODY parts in it's respective basic block.
// The function returns a new basic block.
func genWhile(m *ir.Module, fun *ir.Func, b *ir.Block, n *vir.Node, st, ls *util.Stack) (*ir.Block, error) {
	head := fun.NewBlock("loop_head")
	body := fun.NewBlock("loop_body")
	conv := fun.NewBlock("loop_end")

	// Push loop head to stack such that we can jump to it using CONTINUE statements.
	ls.Push(head)
	defer ls.Pop()

	rel := n.Children[0]
	c1 := n.Children[1]
	var val value.Value

	// Loop head with condition and branch instruction.
	b.NewBr(head)

	// Generate relation for branch.
	if v, err := genRelation(m, fun, b, rel, st); err != nil {
		return nil, err
	} else {
		val = v
	}

	// Check to see if we have to perform loop.
	head.NewCondBr(val, body, conv)

	// Generate LOOP BODY.
	block, err := gen(m, fun, body, c1, st, ls)
	if err != nil {
		return nil, err
	}

	if block == nil {
		// RETURN statement in loop body.
		conv = nil
	}

	// Jump to loop head.
	body.NewBr(head)

	// Return new basic block CONVERGE.
	return conv, nil
}

// genContinue generates a continue statement that jumps to the loop header of the most recently defined loop.
func genContinue(b *ir.Block, ls *util.Stack) (*ir.Block, error) {
	var l interface{}
	if l = ls.Peek(); l == nil {
		return nil, errors.New("no loop header on loop stack")
	}
	b.NewBr(l.(*ir.Block))

	return l.(*ir.Block), nil
}

// genStore generates a store instruction to variable with given name. Error is returned if the variable is undefined.
// The variable is retrieved from the scope stack, innermost first.
func genStore(src value.Value, name string, m *ir.Module, fun *ir.Func, b *ir.Block, st *util.Stack) error {
	// Check all local scopes.
	for i1 := 1; i1 <= st.Size(); i1++ {
		if ht := st.Get(i1); ht != nil {
			if r, ok := ht.(map[string]interface{})[name]; ok {
				fmt.Printf("storing %s in %s\n", src.String(), r.(*ir.InstAlloca).String()) // TODO: delete.
				_ = b.NewStore(src, r.(*ir.InstAlloca))
				return nil
			}
		}
	}

	// Check function scope.
	for _, e1 := range fun.Params {
		if e1.Name() == name {
			_ = b.NewStore(src, e1)
			return nil
		}
	}

	// Check global scope.
	for _, e1 := range m.Globals {
		if e1.Name() == name {
			b.NewStore(src, e1)
			return nil
		}
	}
	return fmt.Errorf("undeclared identifier %q", name)
}

// genLoad generates a load instruction from variable with given name. Error is returned if the variable is undefined.
// The variable is retrieved from the scope stack, innermost first.
func genLoad(name string, m *ir.Module, fun *ir.Func, b *ir.Block, st *util.Stack) (*ir.InstLoad, error) {
	// Check all local scopes.
	for i1 := 1; i1 <= st.Size(); i1++ {
		if ht := st.Get(i1); ht != nil {
			if r, ok := ht.(map[string]interface{})[name]; ok {
				// TODO: dst is referencing the allocated memory, not new virtual register!
				dst := b.NewLoad(r.(*ir.InstAlloca).ElemType, r.(*ir.InstAlloca))
				fmt.Println(dst.LLString())
				fmt.Printf("loading variable %q from %s which is put in %s\n",
					name, r.(*ir.InstAlloca), dst.String())
				return dst, nil
			}
		}
	}

	// Check function scope.
	for _, e1 := range fun.Params {
		if e1.Name() == name {
			dst := b.NewLoad(e1.Type(), e1)
			return dst, nil
		}
	}

	// Check global scope.
	for _, e1 := range m.Globals {
		if e1.Name() == name {
			dst := b.NewLoad(e1.Typ, e1)
			return dst, nil
		}
	}
	//if r, ok := globals.get(name); ok {
	//	dst := b.NewLoad((*r).Type(), *r)
	//	return dst, nil
	//}
	return nil, errors.New("not implemented yet")
}

// get safely returns a variable from the symbol table, if it exists. If entry does not exist the bool is set false.
func (st *symTab) get(name string) (*value.Value, bool) {
	st.Lock()
	defer st.Unlock()
	if val, ok := st.ht[name]; ok {
		return val.(*value.Value), ok
	}
	return nil, false
}

// put safely inserts a new variable into the symbol table.
func (st *symTab) put(name string, val *value.Value) {
	st.Lock()
	defer st.Unlock()
	st.ht[name] = val
}
