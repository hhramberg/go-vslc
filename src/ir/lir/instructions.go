package lir

import (
	"fmt"
	"vslc/src/ir/lir/types"
)

// ----------------------------
// ----- Type definitions -----
// ----------------------------

// DataInstruction defines an arithmetic or bitwise operation instruction, where a result is put in a destination
// register.
type DataInstruction struct {
	b   *Block                    // b is the basic block in which the instruction resides.
	id  int                       // id is the unique identifier assigned to the instruction when it was created.
	op  types.ArithmeticOperation // op defines the arithmetic or bitwise operation of the instruction.
	op1 Value                     // op1 holds the required first operand of the instruction.
	op2 Value                     // op2 holds the second operand (sometimes optional) of the instruction.
	hw  interface{}               // hw is the hardware specific physical register allocated to virtual Value.
	wr  interface{}               // wr is  the wrapper of the node used during register allocation process.
}

// Constant defines an integer or floating point constant.
type Constant struct {
	id   int            // id is the unique identifier assigned to the constant when it was created.
	name string         // name is the optional name given to the constant.
	typ  types.DataType // typ defines the data type of the constant.
	val  interface{}    // val contains the constant value, either integer or floating point.
	hw   interface{}    // The hardware specific physical register allocated to virtual Value.
	wr   interface{}    // wr is  the wrapper of the node used during register allocation process.
}

// BranchInstruction defines an unconditional branch, conditional branch or a return statement.
type BranchInstruction struct {
	b    *Block                 // Basic block that is terminated by this instruction.
	id   int                    // Unique identifier of instruction.
	name string                 // Textual representation of branch instruction.
	typ  types.BranchType       // Type of branch instruction.
	op   types.LogicalOperation // For conditional branches.
	next *Block                 // Next basic block if unconditional or THEN block for a conditional branch.
	els  *Block                 // ELSE block if instruction is a conditional branch.
	val  Value                  // Used for holding the return value for return statement.
	hw   interface{}            // The hardware specific physical register allocated to virtual Value.
	wr   interface{}            // wr is  the wrapper of the node used during register allocation process.
}

// MemoryInstruction defines a memory load or store instruction.
type MemoryInstruction struct {
	b   *Block           // Basic block that owns this instruction.
	id  int              // Unique identifier assigned to instruction.
	typ types.MemoryType // Differentiate between load and store operation.
	src Value            // Source for both load and store instructions.
	dst Value            // Destination in case of store instruction.
	hw  interface{}      // The hardware specific physical register allocated to virtual Value.
	wr  interface{}      // wr is  the wrapper of the node used during register allocation process.
}

// DeclareInstruction defines a memory allocation for a data variable of datatype types.Int or types.Float.
type DeclareInstruction struct {
	b    *Block         // Basic block that owns this instruction.
	id   int            // Unique identifier assigned to instruction.
	name string         // Name of declared variable.
	typ  types.DataType // Data type of declared variable.
	hw   interface{}    // The hardware specific physical register allocated to virtual Value.
	wr   interface{}    // wr is  the wrapper of the node used during register allocation process.
}

// ---------------------
// ----- Constants -----
// ---------------------

// labelDataPrefix is the label used to prefix virtual registers generated by data instructions.
const labelDataPrefix = "r"

// -------------------
// ----- globals -----
// -------------------

// expLut is the lookup table for datatype compatibility across arithmetic and bitwise expressions. The lookup table
// consists of result datatype of expression.
// TODO: Consider changing types.Unknown to types.Int and cast float to integer.
var expLut = [2][2][]types.DataType{
	{
		// Operand 1 is types.Int.
		{
			// Operand 2 is types.Int.
			types.Int, // Add.
			types.Int, // Sub.
			types.Int, // Mul.
			types.Int, // Div.
			types.Int, // Rem.
			types.Int, // LShift.
			types.Int, // RShift.
			types.Int, // Xor.
			types.Int, // Or.
			types.Int, // And.
			types.Int, // Not.
		},
		{
			// Operand 2 is types.Float.
			types.Float,   // Add.
			types.Float,   // Sub.
			types.Float,   // Mul.
			types.Float,   // Div.
			types.Unknown, // Rem.
			types.Unknown, // LShift.
			types.Unknown, // RShift.
			types.Unknown, // Xor.
			types.Unknown, // Or.
			types.Unknown, // And.
			types.Unknown, // Not.
		},
	},
	{
		// Operand 1 is types.Float.
		{
			// Operand 2 is types.Int.
			types.Float,   // Add.
			types.Float,   // Sub.
			types.Float,   // Mul.
			types.Float,   // Div.
			types.Unknown, // Rem.
			types.Unknown, // LShift.
			types.Unknown, // RShift.
			types.Unknown, // Xor.
			types.Unknown, // Or.
			types.Unknown, // And.
			types.Unknown, // Not.
		},
		{
			// Operand 2 is types.Float.
			types.Float,   // Add.
			types.Float,   // Sub.
			types.Float,   // Mul.
			types.Float,   // Div.
			types.Unknown, // Rem.
			types.Unknown, // LShift.
			types.Unknown, // RShift.
			types.Unknown, // Xor.
			types.Unknown, // Or.
			types.Unknown, // And.
			types.Unknown, // Not.
		},
	},
}

// ---------------------
// ----- functions -----
// ---------------------

// ----------------------------
// ----- Data instruction -----
// ----------------------------

// Id returns the unique sequence number assigned to DataInstruction d when it was created.
func (d *DataInstruction) Id() int {
	return d.id
}

// Name returns the given name, if any, or the assigned unique label and sequence id concatenation.
func (d *DataInstruction) Name() string {
	return fmt.Sprintf("%s%d", labelDataPrefix, d.id)
}

// Type returns the types.Data data object type.
func (d *DataInstruction) Type() types.Type {
	return types.Data
}

// DataType returns the data type value of DataInstruction d, either types.Int or types.Float.
func (d *DataInstruction) DataType() types.DataType {
	return expLut[d.op1.DataType()][d.op1.DataType()][d.op]
}

// String returns the textual LIR representation of DataInstruction d.
func (d *DataInstruction) String() string {
	if d.op == types.Not {
		return fmt.Sprintf("%s = %s %s", d.Name(), d.op.String(), d.op1.Name())
	}
	return fmt.Sprintf("%s = %s %s, %s", d.Name(), d.op.String(), d.op1.Name(), d.op2.Name())
}

// Has2Operands returns true for all DataInstruction of type not equal to Not operation.
func (d *DataInstruction) Has2Operands() bool {
	return d.op != types.Not
}

// Has1Operand returns true for DeclareInstruction of typ Not operation.
func (d *DataInstruction) Has1Operand() bool {
	return d.op == types.Not
}

// GetOperand1 returns DataInstruction d's first operand.
func (d *DataInstruction) GetOperand1() Value {
	return d.op1
}

// GetOperand2 returns DataInstruction d's second operand.
func (d *DataInstruction) GetOperand2() Value {
	if d.op == types.Not {
		panic("no second operand for NOT instruction")
	}
	return d.op2
}

// SetHW sets the physical register for DataInstruction d to the input argument i.
func (d *DataInstruction) SetHW(r interface{}) {
	d.hw = r
}

// GetHW returns the physical register for DataInstruction d.
func (d *DataInstruction) GetHW() interface{} {
	return d.hw
}

// SetWrapper sets the wrapper for this instruction during register allocation.
func (d *DataInstruction) SetWrapper(wr interface{}) {
	d.wr = wr
}

// GetWrapper sets the wrapper for this instruction during register allocation.
func (d *DataInstruction) GetWrapper() interface{} {
	return d.wr
}

// IsConstant returns false for DataInstruction.
func (d *DataInstruction) IsConstant() bool {
	return false
}

// --------------------------------
// ----- Constant instruction -----
// --------------------------------

// Id returns the unique sequence number assigned to Constant c when it was created.
func (c *Constant) Id() int {
	return c.id
}

// Name returns the given name, if any, or the assigned unique label and sequence id concatenation.
func (c *Constant) Name() string {
	return c.name
}

// Type returns the types.Data data object type.
func (c *Constant) Type() types.Type {
	return types.Data
}

// DataType returns the data type value of Constant c, either types.Int or types.Float.
func (c *Constant) DataType() types.DataType {
	return c.typ
}

// String returns the textual LIR representation of Constant c.
func (c *Constant) String() string {
	if c.typ == types.Int {
		return fmt.Sprintf("%s = %s(%d)", c.name, c.DataType().String(), c.val)
	}
	return fmt.Sprintf("%s = %s(%f)", c.name, c.DataType().String(), c.val)
}

// GetOperand1 panics when called on Constant, because constants don't have Value operands.
func (c *Constant) GetOperand1() Value {
	panic("constant instruction does not have operands")
}

// GetOperand2 panics when called on Constant, because constants don't have Value operands.
func (c *Constant) GetOperand2() Value {
	panic("constant instruction does not have operands")
}

// Has2Operands returns false for Constant, because declarations don't have operands.
func (c *Constant) Has2Operands() bool {
	return false
}

// Has1Operand returns false for Constant, because declarations don't have operands.
func (c *Constant) Has1Operand() bool {
	return false
}

// SetHW sets the physical register for Constant c to the input argument i.
func (c *Constant) SetHW(r interface{}) {
	c.hw = r
}

// GetHW returns the physical register for Constant c.
func (c *Constant) GetHW() interface{} {
	return c.hw
}

// SetWrapper sets the wrapper for this instruction during register allocation.
func (c *Constant) SetWrapper(wr interface{}) {
	c.wr = wr
}

// GetWrapper sets the wrapper for this instruction during register allocation.
func (c *Constant) GetWrapper() interface{} {
	return c.wr
}

// IsConstant returns true for Constant.
func (d *Constant) IsConstant() bool {
	return true
}

// ------------------------------
// ----- Branch instruction -----
// ------------------------------

// Id returns the unique sequence number assigned to BranchInstruction br when it was created.
func (br *BranchInstruction) Id() int {
	return br.id
}

// Name returns the given name, if any, or the assigned unique label and sequence id concatenation.
func (br *BranchInstruction) Name() string {
	return br.name
}

// Type returns the types.Data data object type.
func (br *BranchInstruction) Type() types.Type {
	return types.Branch
}

// DataType returns the data type value of BranchInstruction br, which types.Unknown.
func (br *BranchInstruction) DataType() types.DataType {
	return types.Unknown
}

// String returns the textual LIR representation of Constant c.
func (br *BranchInstruction) String() string {
	switch br.typ {
	case types.Conditional:
		return fmt.Sprintf("br %s, %s, %s, %s", br.op.String(), br.val.Name(), br.next.Name(), br.els.Name())
	case types.Unconditional:
		return fmt.Sprintf("br %s", br.next.Name())
	case types.Return:
		return fmt.Sprintf("ret %s", br.val.Name())
	}
	panic(fmt.Sprintf("function %s, block %s: unexpected branch type %d",
		br.b.f.Name(), br.b.Name(), br.typ))
}

// GetOperand1 returns the BranchInstruction's first operand, if any.
func (br *BranchInstruction) GetOperand1() Value {
	switch br.typ {
	case types.Conditional:
		return br.val
	case types.Unconditional:
		panic("unconditional branch instruction does not have operands")
	case types.Return:
		return br.val
	default:
		panic(fmt.Sprintf("unexpected branch type on Value %s", br.Name()))
	}
}

// GetOperand2 panics when called on BranchInstruction, because branches don't have two Value operands.
func (br *BranchInstruction) GetOperand2() Value {
	panic("branch instruction does not have second operands")
}

// Has2Operands returns false for BranchInstruction, because declarations don't have two operands.
func (br *BranchInstruction) Has2Operands() bool {
	return false
}

// Has1Operand returns true if conditional or return type BranchInstruction.
func (br *BranchInstruction) Has1Operand() bool {
	if br.typ == types.Conditional || br.typ == types.Return {
		return true
	}
	return false
}

// SetHW sets the physical register for BranchInstruction br to the input argument i.
func (br *BranchInstruction) SetHW(r interface{}) {
	br.hw = r
}

// GetHW returns the physical register for BranchInstruction br.
func (br *BranchInstruction) GetHW() interface{} {
	return br.hw
}

// SetWrapper sets the wrapper for this instruction during register allocation.
func (br *BranchInstruction) SetWrapper(wr interface{}) {
	br.wr = wr
}

// GetWrapper sets the wrapper for this instruction during register allocation.
func (br *BranchInstruction) GetWrapper() interface{} {
	return br.wr
}

// IsConstant returns false for BranchInstruction.
func (d *BranchInstruction) IsConstant() bool {
	return false
}

// ------------------------------
// ----- Memory instruction -----
// ------------------------------

// Id returns the unique sequence number assigned to MemoryInstruction m when it was created.
func (m *MemoryInstruction) Id() int {
	return m.id
}

// Name returns the given name, if any, or the assigned unique label and sequence id concatenation.
func (m *MemoryInstruction) Name() string {
	return fmt.Sprintf("%s%d", labelDataPrefix, m.id)
}

// Type returns the types.Data data object type.
func (m *MemoryInstruction) Type() types.Type {
	if m.typ == types.LoadInstruction {
		return types.Load
	}
	return types.Store
}

// DataType returns the data type value of MemoryInstruction m, either types.Int or types.Float.
func (m *MemoryInstruction) DataType() types.DataType {
	if m.typ == types.StoreInstruction {
		return m.dst.DataType()
	}
	return m.src.DataType()
}

// String returns the textual LIR representation of MemoryInstruction m.
func (m *MemoryInstruction) String() string {
	if m.typ == types.StoreInstruction {
		return fmt.Sprintf("store %s, %s", m.Name(), m.dst.Name())
	}
	return fmt.Sprintf("%s = load %s", m.Name(), m.src.Name())
}

// GetOperand1 returns the MemoryInstruction's first operand, if any.
func (m *MemoryInstruction) GetOperand1() Value {
	//if m.typ == types.Store {
	//	return m.src
	//}
	//panic("load instruction does not have operand")
	return m.src
}

// GetOperand2 panics when called on MemoryInstruction, because branches don't have two Value operands.
func (m *MemoryInstruction) GetOperand2() Value {
	panic("memory instruction does not have second operand")
}

// Has2Operands returns false for MemoryInstruction, because memory instructions don't have two operands.
func (m *MemoryInstruction) Has2Operands() bool {
	return false
}

// Has1Operand returns true if m is a store MemoryInstruction.
func (m *MemoryInstruction) Has1Operand() bool {
	if m.typ == types.StoreInstruction {
		return true
	}
	return false
}

// SetHW sets the physical register for MemoryInstruction m to the input argument i.
func (m *MemoryInstruction) SetHW(r interface{}) {
	m.hw = r
}

// GetHW returns the physical register for MemoryInstruction m.
func (m *MemoryInstruction) GetHW() interface{} {
	return m.hw
}

// SetWrapper sets the wrapper for this instruction during register allocation.
func (m *MemoryInstruction) SetWrapper(wr interface{}) {
	m.wr = wr
}

// GetWrapper sets the wrapper for this instruction during register allocation.
func (m *MemoryInstruction) GetWrapper() interface{} {
	return m.wr
}

// IsConstant returns false for MemoryInstruction.
func (d *MemoryInstruction) IsConstant() bool {
	return false
}

// -----------------------------------
// ----- Declaration instruction -----
// -----------------------------------

// Id returns the unique sequence number assigned to DeclareInstruction d when it was created.
func (d *DeclareInstruction) Id() int {
	return d.id
}

// Name returns the given name, if any, or the assigned unique label and sequence id concatenation.
func (d *DeclareInstruction) Name() string {
	return fmt.Sprintf("%s%d", labelDataPrefix, d.id)
}

// Type returns the types.Data data object type.
func (d *DeclareInstruction) Type() types.Type {
	return types.Local
}

// DataType returns the data type value of DeclareInstruction d, either types.Int or types.Float.
func (d *DeclareInstruction) DataType() types.DataType {
	return d.typ
}

// String returns the textual LIR representation of DeclareInstruction d.
func (d *DeclareInstruction) String() string {
	return fmt.Sprintf("%s = alloc %s", d.Name(), d.typ.String())
}

// Has2Operands returns false for DeclareInstruction, because declarations don't have operands.
func (d *DeclareInstruction) Has2Operands() bool {
	return false
}

// Has1Operand returns false for DeclareInstruction, because declarations don't have operands.
func (d *DeclareInstruction) Has1Operand() bool {
	return false
}

// GetOperand1 panics when called on DeclareInstruction, because declarations don't have Value operands.
func (d *DeclareInstruction) GetOperand1() Value {
	panic("declaration instruction does not have operands")
}

// GetOperand2 panics when called on DeclareInstruction, because declarations don't have Value operands.
func (d *DeclareInstruction) GetOperand2() Value {
	panic("declaration instruction does not have operands")
}

// SetHW sets the physical register for DeclareInstruction d to the input argument i.
func (d *DeclareInstruction) SetHW(r interface{}) {
	d.hw = r
}

// GetHW returns the physical register for DeclareInstruction d.
func (d *DeclareInstruction) GetHW() interface{} {
	return d.hw
}

// SetWrapper sets the wrapper for this instruction during register allocation.
func (d *DeclareInstruction) SetWrapper(wr interface{}) {
	d.wr = wr
}

// GetWrapper sets the wrapper for this instruction during register allocation.
func (d *DeclareInstruction) GetWrapper() interface{} {
	return d.wr
}

// IsConstant returns false for MemoryInstruction.
func (d *DeclareInstruction) IsConstant() bool {
	return false
}
